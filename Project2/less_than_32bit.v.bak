module less_than_32bit(
    input [31:0] a,
    input [31:0] b,
    output lt
);
    wire [31:0] a_xor_b;
    wire [30:0] equal_until;

    // XOR each bit pair to find differing bits
    genvar i;
    generate
        for (i = 0; i < 32; i = i + 1) begin : xor_loop
            xor xor_bit(a_xor_b[i], a[i], b[i]);
        end
    endgenerate

    // Determine if all higher bits are equal
    assign equal_until[30] = ~a_xor_b[31];
    generate
        for (i = 29; i >= 0; i = i - 1) begin : equal_loop
            and and_bit(equal_until[i], equal_until[i + 1], ~a_xor_b[i + 1]);
        end
    endgenerate

    // If A is less than B, A's bit will be 0 and B's bit will be 1 at the first differing bit
    wire [31:0] lt_conditions;
    generate
        for (i = 0; i < 31; i = i + 1) begin : lt_loop
            and and_lt(lt_conditions[i], equal_until[i], ~a[i], b[i]);
        end
    endgenerate

    // Check the least significant bit separately
    and and_lt_lsb(lt_conditions[31], ~a[0], b[0]);

    // Combine all conditions
    or or_lt(lt, lt_conditions[0], lt_conditions[1], lt_conditions[2], lt_conditions[3],
             lt_conditions[4], lt_conditions[5], lt_conditions[6], lt_conditions[7],
             lt_conditions[8], lt_conditions[9], lt_conditions[10], lt_conditions[11],
             lt_conditions[12], lt_conditions[13], lt_conditions[14], lt_conditions[15],
             lt_conditions[16], lt_conditions[17], lt_conditions[18], lt_conditions[19],
             lt_conditions[20], lt_conditions[21], lt_conditions[22], lt_conditions[23],
             lt_conditions[24], lt_conditions[25], lt_conditions[26], lt_conditions[27],
             lt_conditions[28], lt_conditions[29], lt_conditions[30], lt_conditions[31]);
endmodule
